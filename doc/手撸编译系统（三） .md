# 内容概要


# 参考文献
1. [Production rule](https://en.wikipedia.org/wiki/Production_(computer_science))
1. [Formal grammar](https://en.wikipedia.org/wiki/Formal_grammar)
1. <<自己手动构造编译系统>>
1. <<编译器设计>>
1. [为什么递归下降分析中要消除左递归？](https://www.zhihu.com/question/28397643)

# 1. 产生式(Production)
在编译原理中, **产生式** 就是符号替换的重写规则，根据这些重写规则，我们可以由一个符号递归地产生多个符号序列。通常我们在产生式中用 **大写字母** 表示 **非终结符** (需要被继续替换的符号)，用 **小写字母** 表示 **终结符** （不需要且不能被替换的符号）。譬如，下面这条产生式中
```
S->Sa | b
```
`S`是终结符，`a`和`b`是非终结符，`|`表示既可以替换成左边地，也可以替换成右边的。因此这条产生式是说，我们可以把`S`替换成`Sa`或`b`。而`Sa`中的`S`又可以应用产生式规则替换，因此我们就可以得到`Saa`, `ba`, `b`。依此递归，我们不难看出，我可以得到的由终结符组成的符号序列有`b`, `ba`, `baa` `baaa`...。


# 2. 文法定义
Chomsky于1956年建立了形式语言的描述，他把文法分为四种类型，即0型、1型、2型、3型文法，这四种文法对产生式的规则限制依此增多，因此能表达的形式语言也越来越少。其中最重要的两个文法是上下文无关文法(即2型文法)和正则文法(即3型文法)，尽管它们的表达能力要比上下文有关文法（即1型文法）和无限制文法（0型文法）要弱，（0型文法可以表达任意可以被图灵机识别的语言），但是2、3型文法的解析器可以被高效得实现。

前面讨论的词法记号属于3型文法，使用 **确定有限状态自动机(DFA)** 就可以识别，程序设计语言通常使用的是2型文法，需要进行语法分析才能识别。

# 3. 语法分析的作用
**语法分析器(Parser)** 获取词法分析器提供的词法记号序列，根据高级语言文法的结构，识别不同的语法模块。经Parser处理后，高级语言源代码表现为一颗完整的抽象语法树，抽象语法树的子树（包括抽象语法树本身）也称为 **语法模块**。

![Parser inoutput](rc/parser-inoutput.png)

# 4. LL(1) Parser
我们这里要实现的Parser是LL(1) Parser，**LL(1)** Parser是一种高效的自顶向下的Parser。其得名于以下事实：这种Parser由左(Left, L)向右扫描其输入，构建一个最左推导(Leftmost, L)，仅使用一个前看符号(1)。编译器GCC也是使用LL Parser完成C语言的语法分析的，不过GCC使用的是LL(2)分析算法。

## 4.1 LL(1) Parser对产生式的要求
LL(1) Parser要求产生式必须是**右递归**、**右侧无左公因子**。

为什么有这两个要求呢？这是因为LL(1) Parser需要在前看一个符号（词法记号）的情况下唯一确定产生式使用哪一个重写规则。如果出现左递归，譬如下面这条产生式
```
S->Sa | b
```
Parser在读入第一个符号时，会递归下降规则1的最左侧的终结符，但是显然展开了一个无限展开的死循环
```
S->Sa->Saa->Saaa->...
```
如果出现左公因子的话，会导致Parser无法做出唯一的选择。譬如说
```
S->aA | aB
```
LL(1) Parser在前看一个符号`a`后，就不知道该将`S`推导成`aA`还是`aB`。

# 5. <program>的产生式
为了方便表示和理解，我们下面将非终结符放在尖括号里，终结符直接写。

如果用非终结符`<program>`表示高级语言程序，用`<segment>`表示程序的一个的片段，那么高级语言程序与程序片段的关系如下：
```
<program>-><segment><program>
```
通过递归替换，`<program>`可以推导出任意多个`<segment>`，而高级语言程序包含的程序片段肯定是有限多个，因此我们还需要给推导过程一个终止条件。
```
<program>->ε
```
特殊终结符`ε`表示空。我们可以利用`|`将上面两个产生式合并成一条
```
<program>-><segment><program> | ε
```
在该产生式中，不断被替换的非终结符`<program>`出现在产生式的最右侧(当然我们说的是由`|`分隔的每个单元的最右侧)，因此其是右递归的，满足LL(1) Parser的要求。
# 6. 消除左递归和左公因子
## 6.1 消除左递归
你可能会发现，高级语言程序与程序片段的关系还可以这样表示
```
<program>-><program><segment> | ε
```
显然这与前面的产生式完全等价，不过这条产生式是左递归的，不满足LL(1) Parser的要求。我们可以通过改写产生式消除左递归，对于左递归产生式
```
S->Sa | b
```
可以改写成
```
S->bS'
S'->aS' | ε
```
因此`<program>-><program><segment> | ε`改写后变为
```
<program>->ε<program'>
<program'>-><segment><program'> | ε
```
产生式`<program>->ε<program'>`等价于`<program>-><program'>`，这条产生式是冗余的，可以消除。使用非终结符`<program>`代替`<program'>`，即得到产生式`<program>-><segment><program> | ε`。
# 6.2 消除左公因子
消除左公因子很简单，提出来就好了，譬如下面的产生式
```
S->aA | aB
```
可以重写成
```
S->aS'
S'->A | B
```
如果A和B还有左公因子，按上述过程继续重写即可。
# 7. 对`<segment>`进行拆分
程序片段包含变量声明、变量定义、函数声明和函数定义。代码示例如下
```cpp
extern int name; // declare variable 'name'
int name; // define variable 'name'
int *name; // define pointer variable 'name'
int name(){} // define function 'name'
int name(); // declare function 'name'
```
可以看出，使用`extern`关键字引导的肯定是声明，紧跟`extern`之后的是数据类型，否则引导的代码可能是定义，也可能是函数声明，我们用如下产生式表示`<segment>`
```
<segment>->kw_extern <segment'> | <segment'>
<segment'>-><type><def>
<type>->kw_int | kw_char | kw_void
```
其中`<def>`表示类似`name`, `name=0`, `name()`, `*name=0`, `name(){}`这样的结构。
由于`<segment'>`只有一种推导方式，因此可以将其合并到`<segment>`的产生式内。
```
<segment>->kw_extern <type><def> | <type><def>
<type>->kw_int | kw_char | kw_void
```
不难注意到，根据`<segment>`的产生式定义,如下代码也会被识别成三个`<segment>`
```
extern int name =0;
extern int name(){}
extern int name(); 
```
我们使用`extern`关键字是希望其后的变量在其他编译单元中定义，函数的声明和定义不需要加`extern`。因此我们不希望上面三行代码被识别成合法的`segment`。虽然我们可以通过不同的`<def>`形式来完成这种区分，但是这样做会让文法显得更加复杂。对于这种情况，可以将这种合法性检查推迟到语义分析时进行。语义分析时，针对带有`extern`关键字的变量定义、函数声明/定义，让编译器报一个语义错误。这也说明了一点，**在语法分析过程中难以或者无法处理的问题，可以由语义分析来辅助解决**。